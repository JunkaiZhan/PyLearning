# =========================================================
# Function: print_info/warning/error
# Description: Print info in different level
# =========================================================
def print_info(str):
    print("\033[1;34m]" + str + "\033[0m]") # in blue color

def print_warning(str):
    print("\033[1;33m]" + str + "\033[0m]") # in yellow color

def print_error(str):
    print("\033[1;35m]" + str + "\033[0m]") # in red color


# =========================================================
# Function: process_io_file(inst_io_file)
# Description: inst_io_file is the NPI output
# =========================================================
def process_io_file(inst_io_file):

    inst_io_old = open(inst_io_file, 'r')
    inst_io_new = open("interface_io_set.txt", 'w')

    io_list  = inst_io_old.readlines()

    for _ in io_list:
        if "npiIODecl" in _:
            temp_io = _.split(",")[1]
            temp_io = re.sub(r'\s', '', temp_io, count = 0)
            inst_io_new.write(temp_io + "\n")
        inst_io_new.write(_)

    inst_io_old.close()
    inst_io_new.close()


# ========================================================================
# Function: extract_axi_signal(x,x,x)
# Description: Arg config is the json info read from interface_config.json, 
#   Arg hier_dict is the full path dict based on hier_auto file, and Arg 
#   signal_file_path is the directory path of NPI output.
# ========================================================================
def extract_axi_signal(config, hier_dict, signal_file_path = "./interface_io_set.txt"):

    # Get axi focus signals list --------------------------------------
    axi_aw_signals = config["axi_aw_signals_level_1"]
    axi_ar_signals = config["axi_ar_signals_level_1"]
    axi_w_signals  = config["axi_w_signals"]
    axi_r_signals  = config["axi_r_signals"]
    axi_b_signal   = config["axi_b_signals"]
    axi_signals    = axi_aw_signals + axi_ar_signals + axi_w_signals + axi_r_signals + axi_b_signal

    # Signal file split and rename the signal path --------------------
    with open(signal_file_path, 'r') as sf:
        sf_text  = sf.read()
        sf_split = sf.split("\nSPLIT LINE\n")
        sf_num   = len(sf_split) - 1 # Because the last one is empty string
        
        if not sf_num == len(hier_dict):
            print_error("ERROR: The length of singal_file generated by NPI != the length of hier_dict.")
            sys.exit(1)
        
        index = 0
        for macro in hier_dict: # TODO: The order should be equivalent to the order of writing macro path in NPI input file
            with open("io_of_macro_" + macro + ".txt", 'w') as sf_out:
                sf_out.write(sf_split[index])
            index += 1 

    # Generate src signals set and dst signals set --------------------
    conn_num  = config["conn_num"]
    for index in range(conn_num):
        
        print_info(">>> Start process conn_" + str(index) + " ......")
        cur_conn_signal_pair_file = open("conn_" + str(index) + "_signal_pairs.txt", "w")

        # Load the conn config
        cur_conn = config["conn_" + str(index)]
        src_inst = cur_conn["src_instance"]
        src_kw   = cur_conn["src_signals_keyword"]
        src_pre  = cur_conn["src_signals_prefix"]
        src_post = cur_conn["src_signals_postfix"]
        dst_inst = cur_conn["dst_instance"]
        dst_kw   = cur_conn["dst_signals_keyword"]
        dst_pre  = cur_conn["dst_signals_prefix"]
        dst_post = cur_conn["dst_signals_postfix"]

        src_io_file = open("io_of_macro_" + src_inst + ".txt", 'r')
        dst_io_file = open("io_of_macro_" + dst_inst + ".txt", 'r')
        src_io_lines = src_io_file.readlines()
        dst_io_lines = dst_io_file.readlines()

        for axi_signal in axi_signals:
            src_valid_io = ""
            dst_valid_io = ""
            for src_io in src_io_lines:
                if src_kw in src_io and (src_pre + axi_signal + src_post) == src_io:
                    src_valid_io = src_io
                    for dst_io in dst_io_lines:
                        if dst_kw in dst_io and (dst_pre + axi_signal + dst_post) == dst_io:
                            dst_valid_io = dst_io
                            break
                    break
            if src_valid_io == "":
                print_warning("WARNING: The axi_signal: " + axi_signal + " is not found in src_io_file: io_of_macro_" + src_inst + ".txt")
            if dst_valid_io == "":
                print_warning("WARNING: The axi_signal: " + axi_signal + " is not found in dst_io_file: io_of_macro_" + dst_inst + ".txt")
            if not src_valid_io == "" and not dst_valid_io == "":
                src_valid_signal_path = hier_dict[src_inst] + "." + src_valid_io
                dst_valid_signal_path = hier_dict[dst_inst] + "." + dst_valid_io
                cur_conn_signal_pair_file.write(src_valid_signal_path + "  " + dst_valid_signal_path + "\n")

        cur_conn_signal_pair_file.close()
        print_info(">>> Process conn_" + str(index) + " finished.")


# =========================================================
# Function: sig2sig_setup(config)
# Decription: Create sub dir for sig2sig Verdi APP running
# =========================================================
def sig2sig_setup(config):
    
    conn_num  = config["conn_num"]
    verdi_lib = config["verdi_lib_path"]

    # Update elab path in run_app
    run_app_old = open("./run_app", 'r')
    run_app_old_text = run_app_old.read()
    run_app_old.close()
    run_app_new_text = re.sub(r"[\w\/]+.elab++", verdi_lib, run_app_old_text, count = 1)
    run_app_new = open("./run_app", 'w')
    run_app_new.write(run_app_new_text)
    run_app_new.close()

    sh("rm -rf ../output")
    sh("mkdir ../output")
    for index in range(conn_num):
        sh("mkdir ../output/conn_" + str(index))
        sh("mv ./conn_" + str(index) + "_signal_pairs.txt ../output/conn_" + str(index) + "/signal_pairs.txt")
        sh("cp ./run_app ../output/conn_" + str(index) + "/")
        sh("cp ./interface_check.tcl ../output/conn_" + str(index) + "/")


# ========================================================
# Function: sig2sig_run(config):
# Decription: Run the interface check 
# ========================================================
def sig2sig_run(config):

    print_warning("WARNING: Start raise run_app in conn sub dir ......") 
    print_warning("WARNING: Please make sure that the verdi_conn is compiled and ready!")
    conn_num = config["conn_num"]
    for index in range(conn_num):
        sh("cd ../output/conn_" + str(index) + "/ && ./run_app" )



